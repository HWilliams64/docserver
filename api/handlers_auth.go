package api

import (
	"docserver/config"
	"docserver/db"
	"docserver/models"
	"docserver/utils"
	"fmt" // Added
	"net/http"
	"strings" // Added
	"time"

	"github.com/gin-gonic/gin"
)

// SignupRequest defines the expected JSON body for the signup endpoint.
type SignupRequest struct {
	Email     string `json:"email" binding:"required,email"`
	Password  string `json:"password" binding:"required,min=8"` // Add basic password length validation
	FirstName string `json:"first_name" binding:"required"`
	LastName  string `json:"last_name" binding:"required"`
	Extra     any    `json:"extra,omitempty"`
}

// SignupResponse defines the data returned after successful signup (omits hash).
type SignupResponse struct {
	ID             string    `json:"id"`
	FirstName      string    `json:"first_name"`
	LastName       string    `json:"last_name"`
	Email          string    `json:"email"`
	CreationDate   time.Time `json:"creation_date"`
	LastModifiedDate time.Time `json:"last_modified_date"`
	Extra          any       `json:"extra,omitempty"`
}

// SignupHandler handles user registration.
// @Summary      Register a New User Account
// @Description  Creates a new user profile in the system. This is the first step for a new user to start using the service.
// @Description
// @Description  You need to provide your desired `email`, a secure `password` (minimum 8 characters), your `first_name`, and `last_name`.
// @Description  The server will securely hash the password before storing it (meaning the original password is never saved directly).
// @Description  If the email address is already registered, the request will fail.
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        signup body SignupRequest true "User registration details. All fields except 'extra' are required."
// @Success      201  {object}  models.Profile  "Account Created Successfully. The response body contains the details of the newly created profile (excluding the password hash)."
// @Failure      400  {object}  utils.APIError "Bad Request: The data you sent is invalid (e.g., missing required fields, invalid email format, password too short) OR the email address is already in use by another account."
// @Failure      500  {object}  utils.APIError "Internal Server Error: Something went wrong on the server while creating the account (e.g., password hashing failed, database connection issue)."
// @Router       /auth/signup [post]
func SignupHandler(c *gin.Context, database *db.Database, cfg *config.Config) {
	var req SignupRequest

	// Bind JSON request body to the SignupRequest struct
	// Gin's binding also performs validation based on tags.
	if err := c.ShouldBindJSON(&req); err != nil {
		utils.GinBadRequest(c, fmt.Sprintf("Invalid request body: %v", err))
		return
	}

	// Hash the password
	hashedPassword, err := utils.HashPassword(req.Password, cfg.BcryptCost)
	if err != nil {
		// HashPassword already logs the error
		utils.GinInternalServerError(c, "Failed to process password.")
		return
	}

	// Create profile model
	now := time.Now().UTC()
	profile := models.Profile{
		// ID will be generated by db.CreateProfile
		FirstName:      req.FirstName,
		LastName:       req.LastName,
		Email:          req.Email, // Consider lowercasing email for consistency?
		PasswordHash:   hashedPassword,
		CreationDate:   now,
		LastModifiedDate: now,
		Extra:          req.Extra,
	}

	// Attempt to create profile in the database
	createdProfile, err := database.CreateProfile(profile)
	if err != nil {
		// Check if it's a duplicate email error (or other specific errors)
		// Assuming CreateProfile returns an error containing "already exists" for duplicates
		if strings.Contains(err.Error(), "already exists") { // Make check less brittle
			utils.GinBadRequest(c, err.Error()) // Use 400 Bad Request as expected by test
		} else {
			utils.GinInternalServerError(c, fmt.Sprintf("Failed to create profile: %v", err))
		}
		return
	}

	// Important: Do NOT return the password hash in the response.
	// The Profile struct already has `json:"-"` on PasswordHash.

	// Create response object excluding the hash
	response := SignupResponse{
		ID:             createdProfile.ID,
		FirstName:      createdProfile.FirstName,
		LastName:       createdProfile.LastName,
		Email:          createdProfile.Email,
		CreationDate:   createdProfile.CreationDate,
		LastModifiedDate: createdProfile.LastModifiedDate,
		Extra:          createdProfile.Extra,
	}

	// Return the response object
	c.JSON(http.StatusCreated, response)
}

// --- Login Handler (Placeholder) ---

// LoginRequest defines the expected JSON body for the login endpoint.
type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
}

// LoginResponse defines the JSON response for a successful login.
type LoginResponse struct {
	Token string `json:"token"`
}

// LoginHandler handles user authentication and JWT generation.
// @Summary      Log In to Your Account
// @Description  Authenticates a user using their registered email and password.
// @Description
// @Description  If the credentials are correct, the server generates a JSON Web Token (JWT). This token acts like a temporary key or session ID.
// @Description  You need to include this JWT in the `Authorization` header (as a Bearer token) for subsequent requests to protected endpoints (like accessing your profile or documents).
// @Description  Example Header: `Authorization: Bearer <your_token_here>`
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        login body LoginRequest true "Your email and password."
// @Success      200  {object}  LoginResponse "Login Successful. The response body contains the JWT access token."
// @Failure      400  {object}  utils.APIError "Bad Request: The data you sent is invalid (e.g., missing email or password, incorrect JSON format)."
// @Failure      401  {object}  utils.APIError "Unauthorized: The email or password you provided is incorrect. Please check your credentials."
// @Failure      500  {object}  utils.APIError "Internal Server Error: Something went wrong on the server during login (e.g., database issue, error generating the JWT)."
// @Router       /auth/login [post]
func LoginHandler(c *gin.Context, database *db.Database, cfg *config.Config) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		utils.GinBadRequest(c, fmt.Sprintf("Invalid request body: %v", err))
		return
	}

	// Find profile by email
	profile, found := database.GetProfileByEmail(req.Email)
	if !found {
		utils.GinUnauthorized(c, "Invalid email or password")
		return
	}

	// Check password hash
	if !utils.CheckPasswordHash(req.Password, profile.PasswordHash) {
		utils.GinUnauthorized(c, "Invalid email or password")
		return
	}

	// Generate JWT
	tokenString, err := utils.GenerateJWT(&profile, cfg)
	if err != nil {
		// GenerateJWT logs the error
		utils.GinInternalServerError(c, "Failed to generate authentication token.")
		return
	}

	// Return token
	c.JSON(http.StatusOK, LoginResponse{Token: tokenString})
}

// --- Logout Handler (Placeholder) ---

// LogoutHandler handles user logout.
// @Summary      Log Out (Client-Side Action)
// @Description  Indicates the intention to log out. Since JWTs are stateless (the server doesn't keep track of active tokens), true logout happens on the client-side.
// @Description
// @Description  **Action Required by Client:** To effectively log out, the client application (e.g., your web browser or mobile app) MUST delete or discard the stored JWT access token.
// @Description  Calling this endpoint doesn't invalidate the token on the server, but it serves as a conventional way to signal the end of a session in API design.
// @Tags         Authentication
// @Security     BearerAuth
// @Success      204  "Logout Signaled. No content is returned. Remember to discard the JWT on the client."
// @Failure      401  {object}  utils.APIError "Unauthorized: Although logout is client-side, this endpoint might still require a valid token to be called as per API design consistency."
// @Router       /auth/logout [post]
func LogoutHandler(c *gin.Context, database *db.Database, cfg *config.Config) {
	// No server-side action needed as JWTs are stateless.
	// Client is responsible for discarding the token.
	// Just return 204 No Content.
	c.Status(http.StatusNoContent)
}

// --- Forgot/Reset Password Handlers (Placeholders) ---

// ForgotPasswordRequest defines the body for the forgot password request.
type ForgotPasswordRequest struct {
	Email string `json:"email" binding:"required,email"`
}

// ForgotPasswordHandler generates and stores an OTP.
// @Summary      Request Password Reset Code (OTP)
// @Description  Initiates the password reset process by requesting a One-Time Password (OTP) to be sent (conceptually) to the user's registered email address.
// @Description
// @Description  Provide the `email` address associated with the account you want to reset the password for.
// @Description  **Security Note:** To prevent attackers from figuring out which emails are registered ("email enumeration"), this endpoint will *always* return a `202 Accepted` response, regardless of whether the email exists in the system or not.
// @Description  If the email *does* exist, the server generates an OTP, stores it temporarily, and (in a real system) would send it via email. The OTP is needed for the `/auth/reset-password` step.
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        forgotPassword body ForgotPasswordRequest true "The email address for the account needing a password reset."
// @Success      202  "Request Accepted. If the email address is registered, an OTP has been generated (and would typically be emailed). Check your email for the code."
// @Failure      400  {object}  utils.APIError "Bad Request: The request body is invalid (e.g., missing email or invalid format)."
// @Failure      500  {object}  utils.APIError "Internal Server Error: Something went wrong on the server while processing the request (e.g., OTP generation failed)."
// @Router       /auth/forgot-password [post]
func ForgotPasswordHandler(c *gin.Context, database *db.Database, cfg *config.Config) {
	var req ForgotPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		utils.GinBadRequest(c, fmt.Sprintf("Invalid request body: %v", err))
		return
	}

	// Check if email exists
	_, found := database.GetProfileByEmail(req.Email)
	if found {
		// Generate and store OTP (GenerateAndStoreOTP logs it)
		_, err := utils.GenerateAndStoreOTP(req.Email, database) // Pass database instance
		if err != nil {
			// Should not happen with in-memory store unless rand fails
			utils.GinInternalServerError(c, fmt.Sprintf("Failed to generate OTP: %v", err))
			return
		}
	} else {
		// Log that the email wasn't found, but don't tell the user
		fmt.Printf("INFO: Forgot password request for non-existent email: %s\n", req.Email)
	}

	// Always return 202 Accepted to prevent email enumeration attacks
	c.Status(http.StatusAccepted)
}

// ResetPasswordRequest defines the body for the reset password request.
type ResetPasswordRequest struct {
	Email       string `json:"email" binding:"required,email"`
	OTP         string `json:"otp" binding:"required"`
	NewPassword string `json:"new_password" binding:"required,min=8"`
}

// ResetPasswordHandler verifies OTP and updates the password.
// @Summary      Set New Password Using Reset Code (OTP)
// @Description  Completes the password reset process by setting a new password for the account.
// @Description
// @Description  You must provide:
// @Description  *   The `email` address of the account.
// @Description  *   The `otp` (One-Time Password) received after calling `/auth/forgot-password`.
// @Description  *   The desired `new_password` (must meet minimum length requirements, e.g., 8 characters).
// @Description
// @Description  The server will first verify if the provided OTP is correct and hasn't expired for the given email. If valid, it will hash the `new_password` and update the user's account.
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        resetPassword body ResetPasswordRequest true "Email, OTP, and the new password."
// @Success      204  "Password Reset Successful. Your new password is now active. You can log in using it. No content is returned in the response body."
// @Failure      400  {object}  utils.APIError "Bad Request: The request body is invalid (e.g., missing fields, new password too short)."
// @Failure      401  {object}  utils.APIError "Unauthorized: The provided OTP is incorrect, expired, or does not match the email address."
// @Failure      404  {object}  utils.APIError "Not Found: The profile associated with the email address could not be found (e.g., it might have been deleted after the OTP was requested)."
// @Failure      500  {object}  utils.APIError "Internal Server Error: Something went wrong on the server (e.g., hashing the new password failed, database update failed)."
// @Router       /auth/reset-password [post]
func ResetPasswordHandler(c *gin.Context, database *db.Database, cfg *config.Config) {
	var req ResetPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		utils.GinBadRequest(c, fmt.Sprintf("Invalid request body: %v", err))
		return
	}

	// Verify OTP
	validOTP, err := utils.VerifyOTP(req.Email, req.OTP, database) // Pass database instance
	if err != nil {
		// VerifyOTP returns specific errors for expired/invalid/not found
		utils.GinUnauthorized(c, err.Error()) // Use 401 for OTP issues
		return
	}
	if !validOTP {
		// Should be caught by err != nil, but defensive check
		utils.GinUnauthorized(c, "Invalid OTP.")
		return
	}

	// Hash the new password
	newHashedPassword, err := utils.HashPassword(req.NewPassword, cfg.BcryptCost)
	if err != nil {
		utils.GinInternalServerError(c, "Failed to process new password.")
		return
	}

	// Update the password in the database using the dedicated method
	err = database.UpdateProfilePassword(req.Email, newHashedPassword)
	if err != nil {
		// This could happen if the profile was deleted between OTP generation and reset
		if strings.Contains(strings.ToLower(err.Error()), "not found") {
			utils.GinNotFound(c, err.Error())
		} else {
			utils.GinInternalServerError(c, fmt.Sprintf("Failed to update password: %v", err))
		}
		return
	}

	// Success
	c.Status(http.StatusNoContent)
}
